# ERP-система Московского зоопарка

## Принципы ООП, применённые в проекте

Архитектура построена на базовых принципах объектно-ориентированного проектирования,
адаптированных под язык Go (в котором отсутствует понятие классов в привычном смысле).

### 1. Инкапсуляция

Каждая подсистема скрывает внутренние детали реализации.
Например, зоопарк (`MoscowZoo`) управляет своими списками животных и инвентаря,
но предоставляет доступ к ним только через методы интерфейса `Zoo`.
Пользователь не может напрямую изменить коллекции животных — только через публичные методы.

### 2. Абстракция

Для всех сущностей созданы интерфейсы, которые описывают поведение, но не реализацию:

- **`IAlive`** — базовый интерфейс для живых существ, содержит метод `Food()` (потребность в пище);
- **`IInventory`** — интерфейс для всех элементов инвентаря, содержит метод `Number()`;
- **`IHerbo`** — интерфейс для травоядных животных, расширяет `IAlive` методом `Friendliness()`.

Это позволяет зоопарку и другим подсистемам работать не с конкретными типами (`Monkey`, `Rabbit`, `Tiger`), а с абстракциями (`IAlive`, `IHerbo`).
В дальнейшем можно добавить новые виды животных без изменения существующего кода.

### 3. Полиморфизм

Полиморфизм реализуется через интерфейсы.
Например, метод `Zoo.Admit(a IAlive)` может принимать любой объект, реализующий `IAlive`,
будь то обезьяна, тигр или кролик.
Таким образом, поведение определяется не типом объекта, а набором реализованных методов.

### 4. Наследование (через встраивание и композицию)

Go не поддерживает классы и классическое наследование, но предоставляет механизм **встраивания (embedding)**.
Например, интерфейс `IHerbo` «наследует» поведение `IAlive`, добавляя собственный метод.
Это позволяет строить иерархии поведения без жёстких связей.

**Почему мы не использовали `class Animal` и `class Predator`:**
в языке Go нет классов, поэтому создавать фиктивные структуры ради имитации наследования было бы ошибкой.
Go ориентирован на **композицию**, а не на наследование.
Каждое животное является самостоятельным типом (`Monkey`, `Tiger`, `Rabbit`, `Wolf`) и реализует нужные интерфейсы напрямую.
Интерфейс `Herbo` вынесен отдельно, потому что только травоядные обладают уровнем дружелюбности и могут попадать в контактный зоопарк.
`Predator` не создавался вовсе, так как множественное наследование в Go отсутствует и в данной архитектуре было бы избыточным —
все необходимые различия определяются интерфейсами и поведением конкретных структур.

---

## Принципы SOLID, применённые в архитектуре

### 1. **S — Single Responsibility Principle (Принцип единственной ответственности)**

Каждый пакет и структура выполняют строго одну задачу:

- `service` управляет логикой зоопарка и клиники;
- `tools` отвечает за ввод, вывод и взаимодействие с пользователем;
- `di` отвечает за сборку зависимостей;
- `Animals` и `things` содержат описания конкретных сущностей.

Изменения в одном пакете не требуют модификации других.

---

### 2. **O — Open/Closed Principle (Принцип открытости/закрытости)**

Система открыта для расширения, но закрыта для изменения.
Добавление новых животных или предметов инвентаря требует только создания новых структур,
реализующих существующие интерфейсы — без изменения логики зоопарка.

---

### 3. **L — Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**

Любой объект, реализующий `IAlive`, может быть подставлен туда, где ожидается `IAlive`.
То есть `Monkey`, `Rabbit` или `Tiger` взаимозаменяемы для методов, работающих с интерфейсами,
и поведение системы останется корректным.

---

### 4. **I — Interface Segregation Principle (Принцип разделения интерфейсов)**

Интерфейсы не перегружены.
Каждый из них определяет только то поведение, которое действительно нужно конкретной группе объектов:

- `IAlive` отвечает за питание;
- `IHerbo` добавляет дружелюбность;
- `IInventory` определяет базовые свойства для учёта.
  Ни один тип не вынужден реализовывать методы, которые ему не нужны.

---

### 5. **D — Dependency Inversion Principle (Принцип инверсии зависимостей)**

Высокоуровневые модули (зоо­парк, консоль, клиника) не зависят от конкретных реализаций.
Все зависимости внедряются через интерфейсы, а их конкретные реализации управляются DI-контейнером.

---

## Использование DI-контейнера

В проекте используется контейнер внедрения зависимостей **`go.uber.org/dig`**.
Он позволяет автоматически создавать и связывать экземпляры структур, обеспечивая слабую связанность компонентов.

### Преимущества внедрения зависимостей:

- **Ослабление связей** — классы (точнее, структуры) не создают свои зависимости вручную;
- **Повторное использование компонентов** — можно легко заменить реализацию, не меняя логику;
- **Простота тестирования** — зависимости можно подменить заглушками или моками;
- **Удобство инициализации** — все связи описаны централизованно, в одном месте.

### Пример конфигурации DI

```go
c := dig.New()

// Регистрация зависимостей
c.Provide(func() service.Zoo { return service.NewMoscowZoo() })
c.Provide(service.NewVetClinic)
c.Provide(tools.NewConsole)

// Запуск
c.Invoke(func(ui *tools.Console) {
    ui.Run()
})
```

DI-контейнер самостоятельно:

- создаёт экземпляр `MoscowZoo`, реализующий интерфейс `service.Zoo`;
- создаёт экземпляр `VetClinic`;
- передаёт их в конструктор `Console`, не требуя ручной передачи зависимостей.

Таким образом, **управление зависимостями инвертировано**:
вместо того чтобы каждый модуль создавал нужные объекты сам,
всё создание контролируется контейнером, а модули просто объявляют, **что им нужно**.

---

## Архитектура проекта

```
HW1_KPO/
├─ cmd/
│  └─ main.go                 # Точка входа
├─ di/
│  └─ di.go                   # DI-контейнер (внедрение зависимостей)
├─ service/
│  ├─ zoo.go                  # Логика зоопарка
│  ├─ clinic.go               # Ветклиника и проверки здоровья
│  └─ constants.go            # Константы (порог дружелюбности, уровни здоровья)
├─ abstraction/               # Интерфейсы доменной модели
│  ├─ IAlive.go
│  ├─ IHerbo.go
│  ├─ IInventory.go
│  └─ ...
├─ Animals/
│  ├─ Monkey.go
│  ├─ Rabbit.go
│  ├─ Tiger.go
│  └─ Wolf.go
├─ things/
│  ├─ computer.go
│  ├─ table.go
│  └─ thing.go
├─ tools/
│  ├─ console.go              # Основной интерфейс взаимодействия с пользователем
│  ├─ input.go                # Ввод данных
│  ├─ commands.go             # Добавление животных и предметов
│  ├─ render.go               # Вывод информации
│  └─ menu_file.go            # Загрузка JSON-меню
├─ data/
│  └─ ru.json                 # Меню на русском языке
└─ go.mod
```

---

## Инструкция по запуску

1️⃣ Распакуйте архив с проектом **HW1_KPO** в любую папку.
Убедитесь, что структура папок соответствует приведённой выше.

2️⃣ Откройте терминал (или командную строку) в папке проекта.

3️⃣ Выполните команду:

```bash
go run ./cmd
```

или

```bash
go run .
```

4️⃣ После запуска появится главное меню.
Навигация осуществляется вводом номера пункта и нажатием **Enter**.

---

## Расширение функционала

Архитектура системы допускает добавление новых элементов без изменения существующих модулей:

- можно реализовать дополнительные политики допуска (например, по возрасту или виду);
- можно подключить хранение данных (например, запись в файл или базу данных);
- можно добавить новые языки интерфейса, просто создав JSON-файл локализации.

---

## Нотация и стиль кода

- Пакеты структурированы по функциональным областям: `service`, `tools`, `di`, `Animals`, `things`.
- Все взаимодействия между модулями выполняются через интерфейсы.
- Консоль реализована в виде структуры `Console` с методами, отвечающими за конкретные действия.
- Ввод и вывод реализован стандартными средствами Go (`fmt`, `bufio`).
- Меню загружается из внешнего JSON-файла для поддержки локализации.
- DI-контейнер управляет созданием и внедрением зависимостей,
  обеспечивая слабую связанность и независимость слоёв программы.

---
